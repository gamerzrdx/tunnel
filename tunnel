#!/bin/bash

#==============================================================================#
#                       üöá Advanced Tunnelsmith Mega üöá                         #
#                   TCP / UDP / TCP+UDP Reverse Tunnel Manager                 #
#==============================================================================#

# --- Configuration ---
REMOTE_HOST="tunnel.nexronodes.qzz.io"
REMOTE_USER="root"
SSH_PORT="58255"
LOG_DIR="/tmp/tunnelsmith_logs"

mkdir -p $LOG_DIR

# --- Colors & Emojis ---
C_RESET='\033[0m'; C_RED='\033[0;31m'; C_GREEN='\033[0;32m'; C_YELLOW='\033[0;33m'
C_BLUE='\033[0;34m'; C_PURPLE='\033[0;35m'; C_CYAN='\033[0;36m'; C_WHITE='\033[1;37m'

EMOJI_TUNNEL="üöá"; 
EMOJI_SUCCESS="‚úÖ"; 
EMOJI_ERROR="‚ùå"; 
EMOJI_STOP="üõë"; 
EMOJI_LIST="üìã"
EMOJI_GEAR="‚öôÔ∏è"; 
EMOJI_LINK="üîó"; 
EMOJI_SPARKLE="‚ú®"; 
EMOJI_WAVE="üëã"

# --- Helper Functions ---
usage() {
    echo -e "${C_WHITE}üöá Advanced Tunnelsmith Mega${C_RESET}"
    echo -e "Usage: $0 <command> [options]\n"
    echo -e "${C_PURPLE}Commands:${C_RESET}"
    echo -e "  make <local_port> [tcp|udp|both]   ${EMOJI_GEAR} Create a tunnel"
    echo -e "  create-multi <local_port> <count> [tcp|udp|both]  ${EMOJI_GEAR} Create multiple tunnels"
    echo -e "  list                               ${EMOJI_LIST} Show active tunnels"
    echo -e "  show                               ${EMOJI_LIST} Show detailed tunnel info"
    echo -e "  kill <pid>                         ${EMOJI_STOP} Kill a tunnel"
    echo -e "  killall                            ${EMOJI_STOP} Kill all tunnels"
    echo -e "  log-tail <pid>                     ${EMOJI_LINK} Tail tunnel log"
    echo -e "  check-port <port>                  ${EMOJI_SPARKLE} Check remote port availability"
    echo -e "  speed-test <local_port>            ${EMOJI_SPARKLE} TCP/UDP basic ping test"
    echo -e "  domain-check                       ${EMOJI_SPARKLE} Check if domain resolves"
    echo -e "  help                               ${EMOJI_WAVE} Show this help"
}

# --- Check args ---
if [ -z "$1" ]; then usage; exit 1; fi

# --- Functions ---
create_tunnel() {
    LOCAL_PORT=$1
    TYPE=${2:-tcp}
    REMOTE_PORT=${3:-$((RANDOM % 55535 + 10000))}
    TCP_PID=""
    UDP_PID=""
    LOG_FILE="$LOG_DIR/tunnel_${TYPE}_${REMOTE_PORT}.log"

    echo -e "${EMOJI_TUNNEL} Creating $TYPE tunnel: localhost:$LOCAL_PORT -> $REMOTE_HOST:$REMOTE_PORT"

    case "$TYPE" in
        tcp)
            nohup ssh -o StrictHostKeyChecking=no -o ExitOnForwardFailure=yes \
                -o ServerAliveInterval=60 -N -R ${REMOTE_PORT}:localhost:${LOCAL_PORT} \
                ${REMOTE_USER}@${REMOTE_HOST} -p ${SSH_PORT} &> $LOG_FILE &
            TCP_PID=$!
            ;;
        udp)
            nohup socat UDP-LISTEN:${REMOTE_PORT},fork UDP:localhost:${LOCAL_PORT} &> $LOG_FILE &
            UDP_PID=$!
            ;;
        both)
            nohup ssh -o StrictHostKeyChecking=no -o ExitOnForwardFailure=yes \
                -o ServerAliveInterval=60 -N -R ${REMOTE_PORT}:localhost:${LOCAL_PORT} \
                ${REMOTE_USER}@${REMOTE_HOST} -p ${SSH_PORT} &> $LOG_FILE &
            TCP_PID=$!
            nohup socat UDP-LISTEN:${REMOTE_PORT},fork UDP:localhost:${LOCAL_PORT} &> $LOG_FILE &
            UDP_PID=$!
            ;;
        *)
            echo -e "${EMOJI_ERROR} Unknown type $TYPE"; return 1
            ;;
    esac

    sleep 2
    [ -n "$TCP_PID" ] && echo -e "${EMOJI_SUCCESS} TCP Tunnel PID: $TCP_PID"
    [ -n "$UDP_PID" ] && echo -e "${EMOJI_SUCCESS} UDP Tunnel PID: $UDP_PID"
    echo -e "Remote Port: $REMOTE_PORT | Log: $LOG_FILE"
}

list_tunnels() {
    echo -e "${EMOJI_LIST} Active tunnels:"
    ps -ef | grep -E "ssh.*-R|socat UDP" | grep -v grep
}

show_tunnels() {
    echo -e "${EMOJI_LIST} Detailed tunnel info:"
    for file in $LOG_DIR/*.log; do
        [ -f "$file" ] && echo -e "\nFile: $file\n$(tail -n 5 $file)"
    done
}

kill_tunnel() {
    PID=$1
    if [ -z "$PID" ]; then echo "Provide PID"; return; fi
    kill $PID && echo -e "${EMOJI_STOP} Killed tunnel $PID"
}

kill_all_tunnels() {
    echo -e "${EMOJI_STOP} Killing all tunnels..."
    PIDS=$(ps -ef | grep -E "ssh.*-R|socat UDP" | grep -v grep | awk '{print $2}')
    [ -n "$PIDS" ] && kill $PIDS && echo "All tunnels terminated."
}

log_tail() {
    PID=$1
    LOG=$(ls $LOG_DIR | grep $PID)
    if [ -f "$LOG_DIR/$LOG" ]; then
        tail -f "$LOG_DIR/$LOG"
    else
        echo "Log not found for PID $PID"
    fi
}

check_port() {
    PORT=$1
    nc -zv $REMOTE_HOST $PORT
}

speed_test() {
    PORT=$1
    ping -c 3 $REMOTE_HOST
    echo "UDP test requires socat, skipped"
}

domain_check() {
    nslookup $REMOTE_HOST
}

create_multi() {
    LOCAL_PORT=$1
    COUNT=$2
    TYPE=${3:-tcp}
    for ((i=0;i<$COUNT;i++)); do
        create_tunnel $LOCAL_PORT $TYPE
        sleep 1
    done
}

# --- Main Case ---
case "$1" in
    make) create_tunnel $2 $3 ;;
    create-multi) create_multi $2 $3 $4 ;;
    list) list_tunnels ;;
    show) show_tunnels ;;
    kill) kill_tunnel $2 ;;
    killall) kill_all_tunnels ;;
    log-tail) log_tail $2 ;;
    check-port) check_port $2 ;;
    speed-test) speed_test $2 ;;
    domain-check) domain_check ;;
    help) usage ;;
    *) usage ;;
esac            echo -e "${EMOJI_SPARKLE} ${C_GREEN}No active tunnels found.${C_RESET}\n"
        fi
        ;;

    kill)
        PID_TO_KILL=$2
        if [[ -z "$PID_TO_KILL" || ! "$PID_TO_KILL" =~ ^[0-9]+$ ]]; then
            echo -e "\n${EMOJI_ERROR} ${C_RED}Provide a valid PID to kill.${C_RESET}"
            echo -e "Find PIDs: ${C_CYAN}$0 list${C_RESET}\n"
            exit 1
        fi
        if ps -p $PID_TO_KILL > /dev/null; then
            kill $PID_TO_KILL
            echo -e "\n${EMOJI_STOP} ${C_GREEN}Tunnel with PID ${C_YELLOW}${PID_TO_KILL}${C_RESET} terminated.${C_RESET}\n"
        else
            echo -e "\n${EMOJI_ERROR} ${C_RED}No process found with PID ${C_YELLOW}${PID_TO_KILL}${C_RESET}.${C_RESET}\n"
        fi
        ;;

    killall)
        echo -e "\n${EMOJI_STOP} ${C_BLUE}Terminating all tunnels on ${C_WHITE}${REMOTE_HOST}${C_RESET}..."
        PIDS_TO_KILL=$(pgrep -f "ssh.*-R.*${REMOTE_HOST}")
        if [ -n "$PIDS_TO_KILL" ]; then
            echo -e "${C_YELLOW}Processes to kill:${C_RESET}"
            pgrep -af "ssh.*-R.*${REMOTE_HOST}"
            read -p "$(echo -e ${C_RED}Are you sure? [y/N] ${C_RESET})" confirm
            if [[ "$confirm" =~ ^[yY](es)?$ ]]; then
                kill $PIDS_TO_KILL
                echo -e "\n${EMOJI_SUCCESS} ${C_GREEN}All tunnels terminated.${C_RESET}\n"
            else
                echo -e "\n${C_YELLOW}Operation cancelled.${C_RESET}\n"
            fi
        else
            echo -e "${EMOJI_SPARKLE} ${C_GREEN}No active tunnels to kill.${C_RESET}\n"
        fi
        ;;

    help)
        usage
        ;;

    *)
        usage
        exit 1
        ;;
esac
